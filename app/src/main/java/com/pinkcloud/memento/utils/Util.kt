package com.pinkcloud.memento.utils

import android.content.ContentUris
import android.content.Context
import android.content.res.Resources
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Matrix
import android.media.ExifInterface
import android.net.Uri
import android.os.Environment
import android.provider.DocumentsContract
import android.provider.MediaStore
import androidx.core.net.toFile
import androidx.work.Data
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.WorkManager
import timber.log.Timber
import java.io.File
import java.time.Instant
import java.time.ZoneId
import java.util.*
import java.util.concurrent.TimeUnit

/**
 * Constants for keys and ids
 * */
object Constants {
    const val KEY_TEMP_IMAGE_PATH = "temp_image_path"
    const val TEMP_FILE_NAME = "temp.jpg"

    const val CHANNEL_ID = "memo_alarm_channel"

    const val MEMO_ID = "memo_id"
    const val FRONT_CAPTION = "front_caption"
    const val IMAGE_PATH = "image_path"

    const val LAST_NOTIFICATION_ID = "last_notification_id"
    const val DAILY_REFRESH_WORK = "daily_refresh_work"

    const val FONT_SIZE = "font_size"
    const val DEFAULT_FONT_SIZE = 16
    const val FONT_TYPE = "font_type"
}

/**
 * Format time in millis to datetime string
 * like 2021/8/4 11:47 PM
 *
 * @return formatted datetime string
 * */
fun formatMillisToDatetime(timeMillis: Long): String {
    val instant = Instant.ofEpochMilli(timeMillis)
    val date = instant.atZone(ZoneId.systemDefault()).toLocalDateTime()
    val lang = Locale.getDefault().language

    val year = date.year
    val month = date.monthValue
    val day = date.dayOfMonth
    val hour = String.format("%02d", date.hour % 12)
    val minute = String.format("%02d", date.minute)

    // 'when' expression below exists because I can't approach local string resources in Util.kt
    // below codes can be replaced with getting string resources from app context.
    var amStr = "AM"; var pmStr = "PM"
    when (lang) {
        Locale.KOREA.language -> {
            amStr = "오전"; pmStr = "오후"
        }
    }
    val ampm = if (date.hour < 12) amStr else pmStr

    return when (lang) {
        Locale.KOREA.language -> "${year}-${month}-${day} $ampm ${hour}:${minute}"
        else -> "${year}-${month}-${day} ${hour}:${minute} $ampm"
    }
}

/**
 * Schedule alarm of a memo
 * @param context instance for WorkManager
 * @param memoId time in millis when the memo is created.
 * @param frontCaption  caption that will be shown when the scheduled notification is generated.
 * @param alarmTime the time when alarm is scheduled in millis.
 *
 * @return uuid string generated from Worker
 * */
fun scheduleAlarm(context: Context, memoId: Long, frontCaption: String?, alarmTime: Long, imagePath: String?): String? {
    val data = Data.Builder()
    data.putLong(Constants.MEMO_ID, memoId)
    data.putString(Constants.FRONT_CAPTION, frontCaption)
    data.putString(Constants.IMAGE_PATH, imagePath)

    val delay = alarmTime - System.currentTimeMillis()
    if (delay <= 0) return null
    val work = OneTimeWorkRequestBuilder<NotificationWorker>().setInputData(data.build())
        .setInitialDelay(delay, TimeUnit.MILLISECONDS).build()

    WorkManager.getInstance(context).enqueue(work)
    return work.id.toString()
}

/**
 * Cancel scheduled alarm
 *
 * @param alarmId id generated by work
 * */
fun cancelAlarm(context: Context, alarmId: String) {
    val uuid = UUID.fromString(alarmId)
    WorkManager.getInstance(context).cancelWorkById(uuid)
}

/**
 * copy temp image to destination
 *
 * @param dstFileName memo image file for the created memo. (image+memoId.jpg)
 * @return memo image absolute path
 * */
fun copyTempImage(context: Context, dstFileName: String): String {
    val srcFile = File(
        context.filesDir,
        Constants.TEMP_FILE_NAME
    )
    val dstFile = File(context.filesDir, dstFileName)
    srcFile.copyTo(dstFile, true)
    return dstFile.absolutePath
}

/**
 * delete a saved image when memo is deleting completely.
 *
 * @param filePath absolute file path of an image of memo.
 * */
fun deleteImage(filePath: String?) {
    filePath?.let {
        val file = File(it)
        file.delete()
    }
}

/**
 * return correctly rotated portrait image if origin image has rotated orientation.
 *
 * @param imagePath absolute file path of an image of a memo.
 * @return correctly rotated portrait image.
 * */
fun getRotatedBitmap(imagePath: String?): Bitmap? {
    if (imagePath == null) return null

    val exif = ExifInterface(imagePath)
    val orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, 1)
    val srcBitmap = BitmapFactory.decodeFile(imagePath)

    val matrix = Matrix()
    when (orientation) {
        ExifInterface.ORIENTATION_ROTATE_90 -> matrix.postRotate(90f)
        ExifInterface.ORIENTATION_ROTATE_180 -> matrix.postRotate(180f)
        ExifInterface.ORIENTATION_ROTATE_270 -> matrix.postRotate(270f)
    }
    return Bitmap.createBitmap(srcBitmap, 0, 0, srcBitmap.width, srcBitmap.height, matrix, true)
}
